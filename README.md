# TCP/IP 소켓 프로그래밍

## 네트워크 프로그래밍

네트워크로 연결된 서로 다른 컴퓨터들이 서로 데이터를 주고 받는 것, 물리적 연결 필수 => 인터넷이라는 물리적 연결이 되어있다.

**!! 소프트웨어적으로 데이터 송신을 도와주는 것이 소켓(Socket)이고 이 소켓은 운영체제에서 제공해준다.**
* 소켓) 네트워크망에 접속하기 위한 도구로 두 컴퓨터 간 연결을 의미한다.
  * _예) 전화망을 통한 목소리 전달하는 전화기가 Socket_
 
1. 소켓 생성은 int socket(int domain, int type, int protocol)로 호출하며 성공시 파일 디스크립터, 실패시 -1을 반환 하게 된다.
2. bind 호출 int bind(int fockfd, struct sockaddr* myaddr, socklen_t addrlen), 성공시 0 실패시 -1
3. listen 호출 int listen(int sockfd, int backlog) 성공시 0 실패시 -1
4. accept 호출 int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen) 성고시 파일 디스크립터, 실패시 -1
   > 요약 하면 아래와 같다.
   > 1. 소켓 생성
   > 2. IP주소와 PORT 번호 할당
   > 3. 연결 요청 가능상태 변경
   > 4. 연결 요청에 대한 수락
   > 즉, 서버 소켓은 리스닝 소켓, 연결요청은 클라이언트 소켓
---
**윈속 프로그래밍을 할때는 WSAStartup 함수를 호출해서 프로그램이 요구하는 윈도우 소켓 버전을 알리고, 해당 지원하는 라이브러리르 초기화 해야한다.**

int WSAStartup(WORD wVersionRequested, LPWSADATA& pWsasData) 성공시 0 실패시 에러코드를 반환

호출 했다면 마지막엔 해제를 시켜야 하기에 WSACleanup함수를 호출하여 해제 시킨다.

**Windows 기반 함수와 Linux와 다르지 않다(자료형 차이) Windows는 파일과 소켓을 구분하지만 Linux에서는 소켓을 파일로 인식한다.**

### 소켓의 타입과 프로토콜의 설정

송수신하는 방법을 정해야한다. 방법을 정하고 그 방법대로 소켓을 생성해야하기 때문이다.
* 프로토콜(Protocol)은 컴퓨터 상호간의 데이터 송수신에 필요한 통신 규약. 즉, 약속이다.

* 프로토콜 체계 -> 도구
  * PF_INET     -> IPv4
  * PF_INET6    -> IPv6
  * PF_LOCAL    -> 로컬통신
  * PF_PACKET   -> Lowlevel 소켓
  * PF_IPX      -> IPX노벨
소켓의 타입은 큰 그림에서의 데이터 전송 방식으로 보이고, 소켓이 생성될 때 타입이 결정되어야 한다.

* PF_INET의 대표 타입 2개
  * 연결 지향형 - 데이터 전송 보장, 연결 속도가 상대적으로 느리다.
   > SOCK_STREAM
   > 1. 중간 데이터 손실이 없다.
   > 2. 전송 순서대로 데이터를 수신한다.
   > 3. 데이터 경계가 없다.
   > 4. 소켓 대 소켓의 연결을 반드시 1대1 구조로 이루어진다.  
  * 비연결 지향형 - 데이터 전송이 보장이 안됨, 연결 속도가 상대적으로 빠르다.
   > SOCK_DGRAM
   > 1. 전송 순서 상관없이 빠른속도로 전달한다.
   > 2. 데이터 손실 및 판손 문제가 있다.
   > 3. 데이터 경계가 존재한다.
   > 4. 한 번에 보낼수 있는 데이터 크기 제한이 있다.
IPv4 TPC와 UDP 소켓 생성 방법은 아래와 같이 설명 할수 있다.
* TCP => socket(PF_INET,SOCK_STERAM,0)
* UDP => socket(PF_INET,SOCK_DGRAM,0)
_데이터 경계가 없는 TCP는 write로 한번에 보내지만 client에서 하나 씩 읽어 냄을 뜻함, UDP는 한번에 보내고 한번에 받는다._

### 주소체계와 데이터정렬

**IP와 PORT** 

**IP**는 인터넷 상 컴퓨터 구분 목적인 주소이다.
* IPv4: 4바이트 주소체계이며 점점 고갈 되어 가고 있다.
* IPv6: 16바이트 주소체계
  > 네트워크 주소를 찾고 호스트 주소로 호스트를 구분 하는 것!
  > 클래스 A는 0-127
  > 클래스 B는 128-191
  > 클래스 C는 192-223
  > 그래서 첫 바이트크기 0으로 시작은 A, 10으로 시작은 B, 110은 C라고 할 수 있다.
**PORT**는 소켓 구분 하게 된다. 16비트로 표현 하여 0-65535, 0-1023까지는 Well-known Port로 용도가 결정되어 있다.
---
주소정보의 표현은 IP와 PORT사이 프로그램에 표현을 왜 할까? 할당하고 확인을 하기 위해서 이다.
구조체 sockaddr_in 에 sin_family, sin_addr, sin_port, sin_zero[8]이 있다. 그래서 bind에서도 주소를 불러오기 때문에 주소를 넣어주는 것이다.
_sin_zero[8]이 왜 그런가? 원래 쓰던 주소표현은 14바이트라 결국 port 2바이트 + IP 4바이트 + 8바이트 = 14바이트로 맞추기 위해서이다_

 
